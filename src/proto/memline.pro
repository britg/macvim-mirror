/* memline.c */
extern int ml_open __ARGS((buf_T *buf));
extern void ml_setname __ARGS((buf_T *buf));
extern void ml_open_files __ARGS((void));
extern void ml_open_file __ARGS((buf_T *buf));
extern void check_need_swap __ARGS((int newfile));
extern void ml_close __ARGS((buf_T *buf, int del_file));
extern void ml_close_all __ARGS((int del_file));
extern void ml_close_notmod __ARGS((void));
extern void ml_timestamp __ARGS((buf_T *buf));
extern void ml_recover __ARGS((void));
extern int recover_names __ARGS((char_u **fname, int list, int nr));
extern void ml_sync_all __ARGS((int check_file, int check_char));
extern void ml_preserve __ARGS((buf_T *buf, int message));
extern char_u *ml_get __ARGS((linenr_T lnum));
extern char_u *ml_get_pos __ARGS((pos_T *pos));
extern char_u *ml_get_curline __ARGS((void));
extern char_u *ml_get_cursor __ARGS((void));
extern char_u *ml_get_buf __ARGS((buf_T *buf, linenr_T lnum, int will_change));
extern int ml_line_alloced __ARGS((void));
extern int ml_append __ARGS((linenr_T lnum, char_u *line, colnr_T len, int newfile));
extern int ml_append_buf __ARGS((buf_T *buf, linenr_T lnum, char_u *line, colnr_T len, int newfile));
extern int ml_replace __ARGS((linenr_T lnum, char_u *line, int copy));
extern int ml_delete __ARGS((linenr_T lnum, int message));
extern void ml_setmarked __ARGS((linenr_T lnum));
extern linenr_T ml_firstmarked __ARGS((void));
extern void ml_clearmarked __ARGS((void));
extern char_u *makeswapname __ARGS((char_u *fname, char_u *ffname, buf_T *buf, char_u *dir_name));
extern char_u *get_file_in_dir __ARGS((char_u *fname, char_u *dname));
extern void ml_setflags __ARGS((buf_T *buf));
extern long ml_find_line_or_offset __ARGS((buf_T *buf, linenr_T lnum, long *offp));
extern void goto_byte __ARGS((long cnt));
/* vim: set ft=c : */
